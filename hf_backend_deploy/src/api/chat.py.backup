"""Chat API endpoint implementation."""

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
import uuid
from datetime import datetime
from pydantic import BaseModel, validator

from ..core.dependencies import get_db_session, get_current_user
from ..models.conversation import ConversationCreate, ConversationResponse
from ..models.message import MessageCreate, MessageResponse
from ..services.conversation_service import ConversationService
from ..services.message_service import MessageService
from ..agents.task_management_agent import process_user_message

router = APIRouter(prefix="/api/{user_id}", tags=["chat"])

# Pydantic model for the chat request with validation
class ChatRequest(BaseModel):
    """Request model for chat endpoint."""
    message: str
    conversation_id: Optional[int] = None  # None for new conversation

    @validator('message')
    def validate_message(cls, v):
        if not v or len(v.strip()) == 0:
            raise ValueError('Message cannot be empty')
        if len(v) > 5000:  # Set a reasonable limit
            raise ValueError('Message too long, must be less than 5000 characters')
        return v.strip()

    @validator('conversation_id')
    def validate_conversation_id(cls, v):
        if v is not None and v <= 0:
            raise ValueError('Conversation ID must be a positive integer')
        return v


# Enhanced response model to support potential tool call information
class ToolCallInfo(BaseModel):
    """Information about a tool call that the AI might make."""
    tool_name: str
    parameters: dict
    execution_status: Optional[str] = None  # pending, executed, failed


class ChatResponse(BaseModel):
    """Response model for chat endpoint."""
    conversation_id: int
    response: str
    message_id: int
    conversation_title: Optional[str] = None
    # Additional fields for potential tool call information (for future use)
    tool_calls: Optional[list[ToolCallInfo]] = []
    has_tool_calls: bool = False


@router.post("/chat", response_model=ChatResponse)
def chat_endpoint(
    user_id: int,
    chat_request: ChatRequest,
    db: Session = Depends(get_db_session),
    current_user: dict = Depends(get_current_user)
):
    """
    Handle chat messages and return AI responses.

    This endpoint supports:
    1. Starting a new conversation (when conversation_id is None)
    2. Continuing an existing conversation (when conversation_id is provided)

    Args:
        user_id: The ID of the user making the request (path parameter)
        chat_request: The chat request containing the message and optional conversation_id
    """
    # Validate user_id
    if user_id <= 0:
        raise HTTPException(status_code=400, detail="User ID must be a positive integer")
    # Validate that the user_id in the path matches the authenticated user
    # (This will be enhanced when proper authentication is implemented)
    if current_user["id"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to access this user's conversations")

    conversation_service = ConversationService(db)
    message_service = MessageService(db)

    # Determine if we're starting a new conversation or continuing an existing one
    if chat_request.conversation_id is None:
        # Create a new conversation
        conversation_data = ConversationCreate(
            user_id=user_id,
            title=f"Conversation {datetime.now().strftime('%Y-%m-%d %H:%M')}"  # Auto-generate title
        )
        conversation = conversation_service.create_conversation(conversation_data)
        conversation_id = conversation.id
    else:
        # Verify the conversation exists and belongs to the user
        existing_conversation = conversation_service.get_conversation_by_id(chat_request.conversation_id)
        if not existing_conversation:
            raise HTTPException(status_code=404, detail="Conversation not found")

        if existing_conversation.user_id != user_id:
            raise HTTPException(status_code=403, detail="Not authorized to access this conversation")

        conversation_id = chat_request.conversation_id

    # Create the user's message
    user_message_data = MessageCreate(
        conversation_id=conversation_id,
        user_id=user_id,
        role="user",
        content=chat_request.message
    )
    user_message = message_service.create_message(user_message_data)

    # Fetch conversation history to provide context to the AI agent
    # (Currently loaded for potential future use - agent doesn't use history yet)
    conversation_history = message_service.get_messages_by_conversation(conversation_id)

    # Process the user message through the AI agent
    # The agent will handle calling the appropriate MCP tools based on user intent
    agent_result = process_user_message(str(user_id), chat_request.message)
    ai_response_content = agent_result.get("response", "I processed your request.")

    # Create the AI's response message
    ai_message_data = MessageCreate(
        conversation_id=conversation_id,
        user_id=user_id,  # In a real app, this might be the AI's ID or 0
        role="assistant",
        content=ai_response_content
    )
    ai_message = message_service.create_message(ai_message_data)

    # Check if the AI response suggests potential tool usage
    has_tool_calls, tool_calls = analyze_for_potential_tool_calls(chat_request.message, ai_response_content)

    # Prepare the response
    response = ChatResponse(
        conversation_id=conversation_id,
        response=ai_response_content,
        message_id=ai_message.id,
        conversation_title=conversation.title if chat_request.conversation_id is None else None,
        has_tool_calls=has_tool_calls,
        tool_calls=tool_calls
    )

    return response


def analyze_for_potential_tool_calls(user_message: str, ai_response: str) -> tuple[bool, list]:
    """
    Analyze the user message and AI response to determine if there are potential tool calls.

    Returns a tuple of (has_tool_calls: bool, tool_calls: list[ToolCallInfo])
    """
    import re

    tool_calls = []

    # Look for keywords that might indicate potential tool usage
    user_lower = user_message.lower()

    # Check for todo/task related keywords
    if any(word in user_lower for word in ["todo", "task", "list", "add", "complete", "done"]):
        tool_calls.append(ToolCallInfo(
            tool_name="todo_manager",
            parameters={"action": "suggest", "query": user_message[:100]}
        ))

    # Check for weather related keywords
    if any(word in user_lower for word in ["weather", "temperature", "forecast", "rain", "sun"]):
        tool_calls.append(ToolCallInfo(
            tool_name="weather_service",
            parameters={"location": "user_location", "query": user_message[:100]}
        ))

    # Check for calculation related keywords
    if any(word in user_lower for word in ["calculate", "math", "sum", "multiply", "divide", "subtract"]):
        tool_calls.append(ToolCallInfo(
            tool_name="calculator",
            parameters={"expression": user_message[:100]}
        ))

    # Check for time/date related keywords
    if any(word in user_lower for word in ["time", "date", "schedule", "calendar", "appointment"]):
        tool_calls.append(ToolCallInfo(
            tool_name="calendar_service",
            parameters={"query": user_message[:100]}
        ))

    # Return whether there are tool calls and the list of tool calls
    return len(tool_calls) > 0, tool_calls


def generate_mock_ai_response(user_message: str) -> str:
    """
    Generate a mock AI response based on the user's message.

    This is a placeholder implementation that will be replaced with actual AI integration.
    For now, it returns structured responses that could simulate AI tool usage.
    """
    import random

    # Sample responses that simulate AI with potential tool usage
    basic_responses = [
        f"I understand you said: '{user_message}'. This is a simulated AI response.",
        f"Thanks for your message: '{user_message}'. I'm processing this with my AI capabilities.",
        f"I've received your input about '{user_message[:50]}{'...' if len(user_message) > 50 else ''}'. Analyzing now..."
    ]

    # Simulate potential tool responses based on keywords
    user_lower = user_message.lower()

    if any(word in user_lower for word in ["todo", "task", "list", "add"]):
        # Simulate a response that might trigger a tool call
        return f"I can help you manage your tasks! I've noted your request about '{user_message[:30]}{'...' if len(user_message) > 30 else ''}'. Would you like me to add this to your todo list?"
    elif any(word in user_lower for word in ["weather", "temperature", "forecast"]):
        return f"You asked about weather. I can fetch current weather information for you. For '{user_message}', I would typically call a weather API."
    elif any(word in user_lower for word in ["time", "date", "now"]):
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"The current time is {current_time}. Regarding your query about '{user_message[:30]}{'...' if len(user_message) > 30 else ''}', I can assist further if needed."
    elif any(word in user_lower for word in ["calculate", "math", "sum", "multiply"]):
        return f"I can help with calculations. For your request '{user_message[:30]}{'...' if len(user_message) > 30 else ''}', I would typically call a calculator tool."
    elif "hello" in user_lower or "hi" in user_lower:
        return "Hello there! How can I assist you today? I'm your AI assistant ready to help with tasks, questions, and more."
    elif "how are you" in user_lower:
        return "I'm functioning optimally, thank you for asking! I'm here to help you with your tasks and questions. What can I assist you with today?"
    elif "thank" in user_lower:
        return "You're welcome! I'm glad I could help. Is there anything else I can assist you with?"
    elif "bye" in user_lower or "goodbye" in user_lower:
        return "Goodbye! Feel free to come back if you have more questions. I'm always here to help when you need assistance."
    else:
        # Return a random basic response
        return random.choice(basic_responses)